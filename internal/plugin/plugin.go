package plugin

import (
	"context"
	"fmt"
	"path"
	"sort"
	"strings"
	"text/template"

	"github.com/bufbuild/protoplugin"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const (
	defaultFilenameSuffix = ".connectclient.go"
	Name                  = "protoc-gen-connectclient-go"

	syntaxFieldNumber  = 12
	packageFieldNumber = 2

	PLUGIN_VERSION = "PLUGIN_VERSION"
)

type options struct {
	pluginVersion    string
	separatePackages bool
}

func Handle(
	ctx context.Context,
	pluginEnv protoplugin.PluginEnv,
	w protoplugin.ResponseWriter,
	r protoplugin.Request,
) error {
	opt := &options{
		pluginVersion: "devel",
	}
	for _, e := range pluginEnv.Environ {
		k, v, ok := strings.Cut(e, "=")
		if !ok {
			continue
		}
		switch k {
		case PLUGIN_VERSION:
			opt.pluginVersion = v
		}
	}
	for _, p := range strings.Split(r.Parameter(), ",") {
		k, v, ok := strings.Cut(p, "=")
		if !ok {
			continue
		}
		switch k {
		case "separate_packages":
			opt.separatePackages = v == "true"
		}
	}
	p, err := protogen.Options{}.New(r.CodeGeneratorRequest())
	if err != nil {
		return err
	}
	if err := generate(opt, p); err != nil {
		return fmt.Errorf("failed to generate code: %v", err)
	}
	response := p.Response()
	w.AddCodeGeneratorResponseFiles(response.GetFile()...)
	w.SetError(response.GetError())
	w.SetFeatureProto3Optional()
	return nil
}

type packageClientData struct {
	filename     string
	pkgName      protogen.GoPackageName
	goImportPath protogen.GoImportPath
	services     []*protogen.Service
}

func generate(opt *options, p *protogen.Plugin) error {
	// gather all servives by a unique key (path)
	all := make(map[string][]*protogen.Service)
	generatedByPackage := make(map[protogen.GoPackageName]*packageClientData)
	for filePath, f := range p.FilesByPath {
		if !f.Generate {
			continue
		}
		for _, s := range f.Services {
			if len(s.Methods) > 0 {
				// api/v1/user_owner
				all[filePath] = append(all[filePath], s)
			}
		}
	}
	if len(all) == 0 {
		return nil
	}
	for filePath, services := range all {
		sort.Slice(services, func(i, j int) bool {
			return services[i].GoName < services[j].GoName
		})
		f := p.FilesByPath[filePath]
		goImportPath := f.GoImportPath
		if opt.separatePackages {
			// To make the generated code more idiomatic, we'll generate the client code into a
			// separate package. This is done by:
			//
			//  1. Appending "client" to the package name. E.g., "apiv1" -> "apiv1client"
			//  2. Changing the generated filename to include the package name. E.g., "api/v1/user" -> "api/v1/apiv1client/user"
			//  3. Setting a new Go import path, by adding the package name to the existing import path.

			f.GoPackageName += "client"
			f.GeneratedFilenamePrefix = path.Join(
				path.Dir(f.GeneratedFilenamePrefix),
				string(f.GoPackageName),
				path.Base(f.GeneratedFilenamePrefix),
			)
			goImportPath = protogen.GoImportPath(path.Join(string(goImportPath), string(f.GoPackageName)))
		}
		g := p.NewGeneratedFile(f.GeneratedFilenamePrefix+defaultFilenameSuffix, goImportPath)
		if opt.separatePackages {
			// Add the original package as an import, so we can reference the base types. This
			// is the main reason we do not modify the original import path. We also need it
			// later on when referencing the base types.
			g.Import(f.GoImportPath)
		}
		// Add imports
		g.QualifiedGoIdent(protogen.GoImportPath("context").Ident(""))

		genStandaloneComments(g, f, syntaxFieldNumber)
		g.P("// Code generated by " + Name + " DO NOT EDIT.")
		g.P("// source: ", f.Desc.Path())
		g.P()
		g.P("package ", f.GoPackageName)
		g.P()

		for _, s := range services {
			typeName := s.GoName + "Client"
			g.P("type ", typeName, " service")
			g.P()
			for _, m := range s.Methods {
				// Skip streaming methods
				if m.Desc.IsStreamingClient() || m.Desc.IsStreamingServer() {
					continue
				}
				name := string(m.Desc.Name())
				if opt.separatePackages {
					name = g.QualifiedGoIdent(f.GoImportPath.Ident(name))
				}
				if err := methodTemplate.Execute(g, methodTemplateData{
					TypeName:   typeName,
					MethodName: m.GoName,
					Request:    name + "Request",
					Response:   name + "Response",
					Procedure:  path.Join("/", string(s.Desc.FullName()), string(m.Desc.Name())),
				}); err != nil {
					return err
				}
			}
		}
		if p, ok := generatedByPackage[f.GoPackageName]; ok {
			p.services = append(p.services, services...)
		} else {
			filename := path.Join(path.Dir(f.GeneratedFilenamePrefix), "client"+defaultFilenameSuffix)
			generatedByPackage[f.GoPackageName] = &packageClientData{
				filename:     filename,
				pkgName:      f.GoPackageName,
				goImportPath: f.GoImportPath,
				services:     services,
			}
		}
	}
	if len(generatedByPackage) > 0 {
		for _, d := range generatedByPackage {
			if err := generatePackageClient(opt, p, d); err != nil {
				return err
			}
		}
	}
	return nil
}

func generatePackageClient(
	opt *options,
	p *protogen.Plugin,
	d *packageClientData,
) error {
	g := p.NewGeneratedFile(d.filename, d.goImportPath)

	// Add imports
	imports := []string{
		"bytes",
		"context",
		"encoding/json",
		"fmt",
		"io",
		"net/http",
		"path",

		"google.golang.org/protobuf/reflect/protoreflect",
		"google.golang.org/protobuf/encoding/protojson",
	}
	for i := range imports {
		// Yes, this is weird, you're typically supposed to use the full Go identifier. But, if
		// Go breaks exported identifiers, then we're in trouble.
		_ = g.QualifiedGoIdent(protogen.GoImportPath(imports[i]).Ident(""))
	}

	g.P("// Code generated by " + Name + " DO NOT EDIT.")
	g.P("// source: ", path.Dir(d.filename))
	g.P()
	g.P("package ", d.pkgName)
	g.P()
	data := struct {
		UserAgent string
		Services  []string
	}{
		UserAgent: "connectclient-go/" + opt.pluginVersion,
	}
	for _, s := range d.services {
		data.Services = append(data.Services, s.GoName)
	}
	sort.Slice(data.Services, func(i, j int) bool {
		return data.Services[i] < data.Services[j]
	})
	golden, err := prepareGoldenClient()
	if err != nil {
		return err
	}
	tmpl, err := template.New("golden_client").Parse(golden)
	if err != nil {
		return err
	}
	if err := tmpl.Execute(g, data); err != nil {
		return err
	}
	return nil
}

// genStandaloneComments prints all leading comments for a FileDescriptorProto location identified
// by the field number n. It is used to print the comments that are not attached to any specific
// element in the file, such as the file itself (12) or package declaration (2).
//
// This function is copied from the protoc-gen-go source code.
//
// https://github.com/protocolbuffers/protobuf-go/blob/v1.33.0/LICENSE
func genStandaloneComments(g *protogen.GeneratedFile, f *protogen.File, n int32) {
	loc := f.Desc.SourceLocations().ByPath(protoreflect.SourcePath{n})
	for _, s := range loc.LeadingDetachedComments {
		g.P(protogen.Comments(s))
		g.P()
	}
	if s := loc.LeadingComments; s != "" {
		g.P(protogen.Comments(s))
		g.P()
	}
}
